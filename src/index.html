<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>claas.dev experimental</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {};
    </script>
    <style type="text/tailwindcss">


        line {
            fill: #fff;
            stroke: #000;
            stroke-miterlimit: 10;
            stroke-width: 20px
        }

        .pinkline {
            fill: #fff;
            stroke: hotpink;
            stroke-miterlimit: 10;
            stroke-width: 20px;
        }

        .pinkline {
            /*Hide for now*/
            stroke: transparent;
        }

        .jump-line {
            stroke-dasharray: 1;
            stroke-dashoffset: 0;
            animation: jump linear 20s infinite;
            stroke: white;
        }
        svg {
            background: black;
        }
        
        /* Idea: make lines move at different speeds
          Idea: overlay one line in background color and retract it at same pace so it looks like is moving in at the beginning; 
          Idea: when hovering over menu line let the line stop slowly and move in the line at the same speed that contains the menu option
          Idea: make lines like strings in an instrument and bounce like them and play sound in browser 
          Idea: Add art quote: "Art - Art is a diverse range of human activity, and resulting product, that involves creative or imaginative talent expressive of technical proficiency, beauty, emotional power, or conceptual ideas. (Wikipedia link with icon)"*/

        
        @keyframes jump {

            0% {
                stroke-dashoffset: 200;
            }
            100% {
                stroke-dashoffset: 0;
            }
        }

    </style>
</head>

<body>
    <svg xmlns="http://www.w3.org/2000/svg" class="h-full w-full">

    </svg>

    <!--<script type="module" src="App.fs.js"></script>-->
    <script>
        const svg = document.querySelector("svg");
        const lines = document.querySelectorAll("line.jump-line");


        // The y axis is the only thing that stays at the same place at the top of the page. All other sides are movable.
        // Get rate of change and x for y = 0 so we can describe all lines as lines that start from the x axis where y = 0, then we frame it more (y =ax +b; y =0)
        const lineDescriptors = [
            // Probably should add more things here 
            { startX: -474.2141376578821, a: 0.46630833482730316 },
            { startX: 762.1099853515625, a: -1.3795121255829337 },
            { startX: 160.5500030517578, a: 2.465134495275926 },
            { startX: 2709.4681983842133, a: -0.28674999872843426 },
            { startX: 1101.6300048828125, a: -3.0777119341277475 },
            { startX: 1037.1300048828125, a: 2.4975137383072306 },
            { startX: 1311.4000244140625, a: -4.253642757586845 },
            { startX: 1083.56005859375, a: 1.4046587938906259 },
            { startX: 2384.226292500661, a: -0.664481969685644 },
            { startX: 2757.1053981438445, a: -0.3446041584014893 },
            { startX: 566.7899780273438, a: 4.704652428497856 },
            { startX: 799.4500122070312, a: 2.9041630716240805 }
        ];

        // Don't recreate the elements this might be better
        const lineCache = [];

        function identity(x) { return x; }
        function resizeCallback([entry]) {
            console.log("Resized");
            const isFirstCallback = lineCache.length === 0;
            function getOrAddLine(index) {
                
                if (!isFirstCallback)
                    return lineCache[index];

                const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                line.id = `line-${index + 1}`;

                // Set standard attributes
                line.setAttribute("pathLength", 100);
                line.classList.add("jump-line");
                lineCache.push(line);
                svg.appendChild(line);
                return line;
            }

            const svg = entry.target;

            const xUpper = entry.contentBoxSize[0].inlineSize;
            const yUpper = entry.contentBoxSize[0].blockSize;
            lineDescriptors
                .map(({ startX, a }) => {
                    // Calculate end
                    const x1 = startX;
                    const y1 = 0;

                    // y = ax + b <=> y - ax = b
                    const b = y1 - (a * x1);
                    const f = (x) => a * x + b;

                    const f0 = f(0);
                    
                    // Starts in x < 0 and hits xLower first
                    if (startX < 0 && 0 < f0 && f0 < yUpper) {
                        // Get x for yLimit
                        const x2 = (yUpper - b) / a;
                        // We only need to render from x1 = 0 as that is visible
                        return { x1: 0, y1: f0, x2, y2: yUpper };
                    }

                    // If hits xLower first
                    if (0 < f0 && f0 < yUpper) {
                        // Then set x2 = 0 and y2 = f(0)
                        return { x1, y1, x2: 0, y2: f0 };
                    }

                    // Hits yUpper first
                    // Might run out of bits to represent the number if it's a really steep line ðŸ¤”
                    if (f0 > yUpper || f(xUpper) > yUpper) {
                        // Get x for yLimit
                        // y = ax + b <=> (y - b) / a = x
                        const x2 = (yUpper - b) / a;
                        return { x1, y1, x2, y2: yUpper };
                    }

                    // Hits xUpper first
                    const fXUpper = f(xUpper);
                    if (0 < fXUpper && fXUpper < yUpper) {
                        return { x1, y1, x2: xUpper, y2: fXUpper };
                    }


                    // Starts in x > xUpper and hits xUpper first
                    if (xUpper < startX && 0 < fXUpper && fXUpper < yUpper) {
                        // Get x for yLimit
                        const x2 = (yUpper - b) / a;
                        return { x1: xUpper, y1: fXUpper, x2, y2: yUpper };
                    }

                    // Edge cases we hit exactly the yUpper corners
                    if (f0 === yUpper) {
                        return { x1, y1, x2: 0, y2: yUpper };
                    }
                    if (fXUpper === yUpper) {
                        return { x1, y1, x2: xUpper, y2: yUpper };
                    }

                    // (all other cases don't need to be rendered as they are not visible and don't cross our view rectangle)
                    return null;
                })
                .filter(identity)
                .forEach(({ x1, y1, x2, y2 }, index) => {

                    const line = getOrAddLine(index);


                    line.setAttribute("x1", x1);
                    line.setAttribute("y1", y1);
                    line.setAttribute("x2", x2);
                    line.setAttribute("y2", y2);

                });
        }
        
        const observer = new ResizeObserver(resizeCallback);
        observer.observe(svg);

    </script>
</body>

</html>