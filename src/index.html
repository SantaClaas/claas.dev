<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>claas.dev experimental</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {};
    </script>
    <style type="text/tailwindcss">


        line {
            fill: #fff;
            stroke: #000;
            stroke-miterlimit: 10;
        }

        .pinkline {
            fill: #fff;
            stroke: hotpink;
            stroke-miterlimit: 10;
            stroke-width: 20px;
        }

        .pinkline {
            /*Hide for now*/
            stroke: transparent;
        }

        .jump-line {
            stroke-dashoffset: 0;
            animation: jump linear 7s infinite;
            stroke: white;
        }
        svg {
            background: black;
        }
        
        /* Idea: make lines move at different speeds
          Idea: overlay one line in background color and retract it at same pace so it looks like is moving in at the beginning; 
          Idea: when hovering over menu line let the line stop slowly and move in the line at the same speed that contains the menu option
          Idea: make lines like strings in an instrument and bounce like them and play sound in browser 
          Idea: Add art quote: "Art - Art is a diverse range of human activity, and resulting product, that involves creative or imaginative talent expressive of technical proficiency, beauty, emotional power, or conceptual ideas. (Wikipedia link with icon)"
          Idea: Make logo in a stary sky and go down into mountains that are from the As*/

        
        @keyframes jump {

            0% {
                stroke-dashoffset: 100;
            }
            100% {
                stroke-dashoffset: 0;
            }
        }

    </style>
</head>

<body>
    <svg xmlns="http://www.w3.org/2000/svg" class="h-full w-full">
    </svg>

    <!--<script type="module" src="App.fs.js"></script>-->
    <script>
        const svg = document.querySelector("svg");
        const lines = document.querySelectorAll("line.jump-line");


        // The y axis is the only thing that stays at the same place at the top of the page. All other sides are movable.
        // Get rate of change and x for y = 0 so we can describe all lines as lines that start from the x axis where y = 0, then we frame it more (y =ax +b; y =0)
        const lineDescriptors = [
            // Probably should add more things here 
            // The ratio is based on where it was on the X axis with a width of 1920
            // 1920 the orignal width it was designed with
            { startXRatio: -0.24698653003014692, a: 0.46630833482730316 },
            { startXRatio: 0.39693228403727215, a: -1.3795121255829337 },
            { startXRatio: 0.08361979325612386, a: 2.465134495275926 },
            { startXRatio: 1.4111813533251112, a: -0.28674999872843426 },
            { startXRatio: 0.5737656275431315, a: -3.0777119341277475 },
            { startXRatio: 0.5401718775431316, a: 2.4975137383072306 },
            { startXRatio: 0.6830208460489909, a: -4.253642757586845 },
            { startXRatio: 0.5643541971842448, a: 1.4046587938906259 },
            { startXRatio: 1.2417845273440944, a: -0.664481969685644 },
            { startXRatio: 1.4359923948665856, a: -0.3446041584014893 },
            { startXRatio: 0.2952031135559082, a: 4.704652428497856 },
            { startXRatio: 0.4163802146911621, a: 2.9041630716240805 }
        ];
        //         

        // Don't recreate the elements this might be better
        const lineCache = new Map();

        // Resize observer observes an initial resize on Chrome Canary and Firefox which can be used
        // but not on Chrome or Safari

        function identity(x) { return x; }
        function resizeCallback([entry]) {
            console.log("Resized");
            const isFirstCallback = lineCache.length === 0;
            function getOrAddLine(index) {

                if (lineCache.has(index))
                    return lineCache.get(index);

                const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                line.id = `line-${index + 1}`;

                // Set standard attributes
                line.classList.add("jump-line");
                lineCache.set(index, line);
                svg.appendChild(line);
                return line;
            }

            // Using body temporarily (see .observe below)
            //const svg = entry.target;

            const xUpper = entry.contentBoxSize[0].inlineSize;
            const yUpper = entry.contentBoxSize[0].blockSize;
            const strokeWidth = Math.min(xUpper / 1920, yUpper / 1080) * 20;
            lineDescriptors
                .map(({ startXRatio, a }) => {
                    // Calculate end
                    // Calculate end with ratio based on width so that the joins are always in the center
                    // 1920 the orignal width it was designed with
                    const x1 = xUpper * startXRatio;
                    const y1 = 0;

                    // y = ax + b <=> y - ax = b
                    const b = y1 - (a * x1);
                    const f = (x) => a * x + b;

                    const f0 = f(0);

                    // Starts in x < 0 and hits xLower first
                    if (x1 < 0 && 0 < f0 && f0 < yUpper) {
                        // Get x for yLimit
                        const x2 = (yUpper - b) / a;
                        // We only need to render from x1 = 0 as that is visible
                        return { x1: 0, y1: f0, x2, y2: yUpper };
                    }

                    // If hits xLower first
                    if (0 < f0 && f0 < yUpper) {
                        // Then set x2 = 0 and y2 = f(0)
                        return { x1, y1, x2: 0, y2: f0 };
                    }

                    // Hits yUpper first
                    // Might run out of bits to represent the number if it's a really steep line ðŸ¤”
                    if (f0 > yUpper || f(xUpper) > yUpper) {
                        // Get x for yLimit
                        // y = ax + b <=> (y - b) / a = x
                        const x2 = (yUpper - b) / a;
                        return { x1, y1, x2, y2: yUpper };
                    }

                    // Hits xUpper first
                    const fXUpper = f(xUpper);
                    if (0 < fXUpper && fXUpper < yUpper) {
                        return { x1, y1, x2: xUpper, y2: fXUpper };
                    }

                    // Starts in x > xUpper and hits xUpper first
                    if (xUpper < x1 && 0 < fXUpper && fXUpper < yUpper) {
                        // Get x for yLimit
                        const x2 = (yUpper - b) / a;
                        return { x1: xUpper, y1: fXUpper, x2, y2: yUpper };
                    }

                    // Edge cases we hit exactly the yUpper corners
                    if (f0 === yUpper) {
                        return { x1, y1, x2: 0, y2: yUpper };
                    }
                    if (fXUpper === yUpper) {
                        return { x1, y1, x2: xUpper, y2: yUpper };
                    }

                    // (all other cases don't need to be rendered as they are not visible and don't cross our view rectangle)
                    return null;
                })
                .filter(identity)
                .forEach(({ x1, y1, x2, y2 }, index) => {

                    const line = getOrAddLine(index);
                    line.setAttribute("x1", x1);
                    line.setAttribute("y1", y1);
                    line.setAttribute("x2", x2);
                    line.setAttribute("y2", y2);
                    line.setAttribute("stroke-width", strokeWidth);
                    
                    
                    // Calculate length and change dasharray size based on that
                    // const dx = x2 - x1;
                    // const dy = y2 - y1;
                    const length = line.getTotalLength();
                    
                    const nominator = 50;
                    const denominator = 100;

                    line.setAttribute("stroke-dasharray", 50 );
                    // line.setAttribute("pathLength", 100);
                    // const lineLength = Math.sqrt(dx**2 - dy**2)
                });
        }

        
        // As the time of writing it the Resize Observer API doesn't seem to be working Chromium and Safari but on Firefox
        // The canary versions of Chromium seem to have it fixed though so maybe I'll revert this later.
        // But for now I'll be using the body as it should have the same size as the SVG because the SVG has the full size of the body
        const observer = new ResizeObserver(resizeCallback);
        // observer.observe(svg);
        observer.observe(document.body);

    </script>
</body>

</html>